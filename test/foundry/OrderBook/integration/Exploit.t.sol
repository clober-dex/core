// SPDX-License-Identifier: -
// License: https://license.clober.io/LICENSE.pdf

pragma solidity ^0.8.0;

import "forge-std/Test.sol";

import "../../../../contracts/interfaces/CloberMarketSwapCallbackReceiver.sol";
import "../../../../contracts/mocks/MockQuoteToken.sol";
import "../../../../contracts/mocks/MockBaseToken.sol";
import "../../../../contracts/mocks/MockPriceBook.sol";
import "../../../../contracts/OrderNFT.sol";
import "../../../../contracts/OrderBook.sol";
import "../utils/MockingFactoryTest.sol";
import "./Constants.sol";

contract ExploitIntegrationTest is Test, CloberMarketSwapCallbackReceiver, MockingFactoryTest {
    event ClaimOrder(
        address indexed claimer,
        address indexed user,
        uint64 rawAmount,
        uint256 bountyAmount,
        uint256 orderIndex,
        uint16 priceIndex,
        bool isBase
    );

    uint256 private constant _MAX_ORDER = 2 ** 15; // 32768
    uint256 private constant _MAX_ORDER_M = 2 ** 15 - 1; // % 32768
    uint16 private constant _MOCK_PRICE_INDEX = 3;
    address private constant _MAKER = address(0x3426);
    address private constant _TAKER = address(0x3423);

    MockQuoteToken quoteToken;
    MockBaseToken baseToken;
    OrderBook orderBook;
    OrderNFT orderToken;

    function setUp() public {
        quoteToken = new MockQuoteToken();
        baseToken = new MockBaseToken();
    }

    function cloberMarketSwapCallback(address tokenIn, address, uint256 amountIn, uint256, bytes calldata)
        external
        payable
    {
        IERC20(tokenIn).transfer(msg.sender, amountIn);
    }

    function _createOrderBook(int24 makerFee, uint24 takerFee) private {
        orderToken = new OrderNFT(address(this), address(this));
        orderBook = new OrderBook(
            address(orderToken),
            address(quoteToken),
            address(baseToken),
            10 ** 4,
            makerFee,
            takerFee,
            address(this),
            address(new MockPriceBook())
        );
        orderToken.init("", "", address(orderBook));

        uint256 _quotePrecision = 10 ** quoteToken.decimals();
        quoteToken.mint(address(this), 1000000000 * _quotePrecision);
        quoteToken.approve(address(orderBook), type(uint256).max);

        uint256 _basePrecision = 10 ** baseToken.decimals();
        baseToken.mint(address(this), 1000000000 * _basePrecision);
        baseToken.approve(address(orderBook), type(uint256).max);
    }

    function _buildLimitOrderOptions(bool isBid, bool postOnly) private pure returns (uint8) {
        return (isBid ? 1 : 0) + (postOnly ? 2 : 0);
    }

    function testFailClaimFeesFailFromRounding() public {
        _createOrderBook(0, 100011); // 10.0011% taker fee

        // create 2 orders
        uint256 orderIndex1 = _createPostOnlyOrder(Constants.BID, 10);
        uint256 orderIndex2 = _createPostOnlyOrder(Constants.BID, 10);

        // take both orders
        _createTakeOrder(Constants.BID, 2 * 10);

        OrderKey[] memory ids = new OrderKey[](2);
        ids[0] = OrderKey({isBid: Constants.BID, priceIndex: _MOCK_PRICE_INDEX, orderIndex: orderIndex1});
        ids[1] = OrderKey({isBid: Constants.BID, priceIndex: _MOCK_PRICE_INDEX, orderIndex: orderIndex2});

        // perform claim
        orderBook.claim(address(this), ids);

        // try to claim fees, will revert
        orderBook.collectFees(address(quoteToken), address(this));
        vm.expectRevert("ERC20: transfer amount exceeds balance");
        orderBook.collectFees(address(quoteToken), daoTreasury);
    }

    function testFailClaimFeesFailFromRoundingWithFuzz(int24 makerFee, uint24 takerFee, uint16 priceIndex) public {
        makerFee = int24(bound(makerFee, Constants.MIN_FEE, int24(Constants.MAX_FEE)));
        takerFee = uint24(bound(takerFee, 0, Constants.MAX_FEE));
        priceIndex = uint16(bound(priceIndex, 0, 100));
        _createOrderBook(makerFee, takerFee);

        // create 4 orders
        uint256 orderIndex1 = _createPostOnlyOrder(Constants.BID, 10);
        uint256 orderIndex2 = _createPostOnlyOrder(Constants.BID, 10);
        uint256 orderIndex3 = _createPostOnlyOrder(Constants.BID, 10);
        uint256 orderIndex4 = _createPostOnlyOrder(Constants.BID, 10);

        // take both orders
        _createTakeOrder(Constants.BID, 4 * 10);

        OrderKey[] memory ids = new OrderKey[](4);
        ids[0] = OrderKey({isBid: Constants.BID, priceIndex: priceIndex, orderIndex: orderIndex1});
        ids[1] = OrderKey({isBid: Constants.BID, priceIndex: priceIndex, orderIndex: orderIndex2});
        ids[2] = OrderKey({isBid: Constants.BID, priceIndex: priceIndex, orderIndex: orderIndex3});
        ids[3] = OrderKey({isBid: Constants.BID, priceIndex: priceIndex, orderIndex: orderIndex4});

        // perform claim
        orderBook.claim(address(this), ids);

        // try to claim fees, will revert
        orderBook.collectFees(address(quoteToken), address(this));
        vm.expectRevert("ERC20: transfer amount exceeds balance");
        orderBook.collectFees(address(quoteToken), daoTreasury);
    }

    function testFailExploitScenarioWithInvalidTokenId() public {
        _createOrderBook(0, 0);
        address attacker = address(0x123);
        address attacker2 = address(0x234);
        address victim = address(0x345);
        // Step 1. Attacker creates an ASK limit order and receives NFT
        uint16 priceIndex = 100;
        uint256 orderIndex = orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({
            user: attacker,
            priceIndex: priceIndex,
            rawAmount: 0,
            baseAmount: 10 ** 18,
            options: _buildLimitOrderOptions(Constants.ASK, Constants.POST_ONLY),
            data: new bytes(0)
        });

        // Step 2. Given the `OrderKey` which represents the created limit order,
        //         an attacker can craft ambiguous tokenIds
        OrderKey memory order_key = OrderKey({isBid: false, priceIndex: priceIndex, orderIndex: orderIndex});
        uint256 tokenId = orderToken.encodeId(order_key);
        uint256 ambiguousTokenId = tokenId + (1 << 255); // crafting ambiguous tokenId

        // Step 3. Attacker approves both victim (can be a third-party protocol like OpenSea) and his other account
        vm.startPrank(attacker);
        orderToken.approve(victim, tokenId);
        orderToken.approve(attacker2, ambiguousTokenId);
        vm.stopPrank();

        // Step 4. Victim transfers the NFT to the themselves. (Or attacker trades it)
        vm.startPrank(victim);
        orderToken.transferFrom(attacker, victim, tokenId);
        vm.stopPrank();

        // Step 5. Attacker steals the NFT
        vm.startPrank(attacker2);
        orderToken.transferFrom(victim, attacker2, ambiguousTokenId);
        vm.stopPrank();
    }

    function testFailExploitScenarioWithOrderTheftWithAmbiguousOrderIndex() public {
        _createOrderBook(0, 0);

        address attacker = address(0x1337);
        address attacker2 = address(0x1338);
        address victim = address(0xbabe);
        // Step 1. Attacker creates an ASK limit order and receives NFT
        uint16 priceIndex = 100;
        uint256 orderIndex = orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({
            user: attacker,
            priceIndex: priceIndex,
            rawAmount: 0,
            baseAmount: 1e18,
            options: _buildLimitOrderOptions(Constants.ASK, Constants.POST_ONLY),
            data: new bytes(0)
        });

        // Step 2. Given the `OrderKey` which represents the created limit order, an attacker can craft ambiguous tokenIds
        OrderKey memory orderKey = OrderKey({isBid: false, priceIndex: priceIndex, orderIndex: orderIndex});
        orderKey.orderIndex += _MAX_ORDER;
        uint256 futureTokenId = orderToken.encodeId(orderKey);

        // Step 3. Attacker approves the futureTokenId to themself, and cancels the current id
        vm.startPrank(attacker);
        orderToken.approve(attacker2, futureTokenId);
        OrderKey[] memory orderKeys = new OrderKey[](1);
        orderKeys[0] = orderKey;
        orderKeys[0].orderIndex = orderIndex; // restore original orderIndex
        orderBook.cancel(attacker, orderKeys);
        vm.stopPrank();

        // Step 4. attacker fills queue, victim creates their order recycles orderIndex 0
        uint256 victimOrderSize = 1e18;
        for (uint256 i = 0; i < _MAX_ORDER; i++) {
            orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({
                user: i < _MAX_ORDER - 1 ? attacker : victim,
                priceIndex: priceIndex,
                rawAmount: 0,
                baseAmount: victimOrderSize,
                options: _buildLimitOrderOptions(Constants.ASK, Constants.POST_ONLY),
                data: new bytes(0)
            });
        }

        assertEq(orderToken.ownerOf(futureTokenId), victim);

        // Step 5. Attacker steals the NFT and can cancel to receive the tokens
        vm.startPrank(attacker2);
        orderToken.transferFrom(victim, attacker, futureTokenId);
        vm.stopPrank();
        assertEq(orderToken.ownerOf(futureTokenId), attacker);

        uint256 baseBalanceBefore = baseToken.balanceOf(attacker);
        vm.startPrank(attacker);
        orderKeys[0].orderIndex = orderIndex + _MAX_ORDER;
        orderBook.cancel(attacker, orderKeys);
        vm.stopPrank();
        assertEq(baseToken.balanceOf(attacker) - baseBalanceBefore, victimOrderSize);
    }

    function testFailPartialClaimWithAmbiguousOrderIndex() public {
        _createOrderBook(0, 0);

        // Step 1. Creates an BID Order and craft ambiguous orderIndex
        uint256 orderIndex = _createPostOnlyOrder(Constants.BID, 10);
        orderIndex += _MAX_ORDER;

        // Step 2. Take the order partially
        _createTakeOrder(Constants.BID, 10 / 2);

        // Step 3. Claim partially taken order and the wrong orderIndex will be included to the ClaimOrder
        OrderKey[] memory ids = new OrderKey[](1);
        ids[0] = OrderKey({isBid: Constants.BID, priceIndex: _MOCK_PRICE_INDEX, orderIndex: orderIndex});

        vm.expectEmit(true, true, true, true);
        // Note that `orderIndex` is the wrong value
        // Below event emission logic should be failed
        emit ClaimOrder(address(this), _MAKER, 5, 0, orderIndex, _MOCK_PRICE_INDEX, Constants.BID);
        orderBook.claim(address(this), ids);
    }

    function _createPostOnlyOrder(bool isBid, uint64 rawAmount) private returns (uint256) {
        if (isBid) {
            return orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({
                user: _MAKER,
                priceIndex: _MOCK_PRICE_INDEX,
                rawAmount: rawAmount,
                baseAmount: 0,
                options: 3,
                data: new bytes(0)
            });
        } else {
            return orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({
                user: _MAKER,
                priceIndex: _MOCK_PRICE_INDEX,
                rawAmount: 0,
                baseAmount: orderBook.rawToBase(rawAmount, _MOCK_PRICE_INDEX, true),
                options: 2,
                data: new bytes(0)
            });
        }
    }

    function _createTakeOrder(bool isTakingBid, uint64 rawAmount) private {
        if (isTakingBid) {
            orderBook.limitOrder({
                user: _TAKER,
                priceIndex: _MOCK_PRICE_INDEX,
                rawAmount: 0,
                baseAmount: orderBook.rawToBase(rawAmount, _MOCK_PRICE_INDEX, true),
                options: 0,
                data: new bytes(0)
            });
        } else {
            orderBook.limitOrder({
                user: _TAKER,
                priceIndex: _MOCK_PRICE_INDEX,
                rawAmount: rawAmount,
                baseAmount: 0,
                options: 1,
                data: new bytes(0)
            });
        }
    }
}
